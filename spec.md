## 1. プロジェクト概要

- 名称: MLB Score Notifier (仮称)
- 種別: Electron ベースのクロスプラットフォームデスクトップアプリ
- 目的: ユーザーが登録した MLB チームの得点イベントをリアルタイムで通知する
- 対象ユーザー: MLB ファン、特定チームをフォローしたいユーザー
- 主要 KPI: 得点イベント検知遅延、通知クリック率、アクティブユーザー数
- 対応プラットフォーム (初期): macOS

## 2. スコープ定義

### 2.1 スコープ内

- MLB Stats API を利用したチーム・試合情報の取得
- ユーザーによるチーム選択および監視設定
- OS ネイティブ通知を用いたデスクトップ通知
- 基本的な試合情報の表示 (イニング、スコア)
- 通知履歴の簡易表示
- 設定 (ポーリング間隔、通知サウンド ON/OFF)
- バックグラウンド常駐は初期リリースでは非対応 (ウィンドウクローズ時に監視停止)

### 2.2 スコープ外 (初期リリース)

- モバイルアプリ化
- リアルタイムストリーミング (Webhook / WebSocket)
- ベットオッズや詳細スタッツの可視化
- SNS 連携や共有機能

## 3. システム構成概要

- Electron main プロセス: バックグラウンド監視、通知、設定保存
- Renderer プロセス (React + TypeScript 想定): UI 表示、IPC 経由での状態制御
- ローカルストレージ: 設定情報、通知済みイベントキャッシュ
- 外部サービス: MLB Stats API (https://statsapi.mlb.com)

## 4. MLB Stats API 利用方針

- 主なエンドポイント
  - チーム一覧: `GET /api/v1/teams?sportId=1`
  - 当日スケジュール: `GET /api/v1/schedule?sportId=1&teamId={id}&date={YYYY-MM-DD}`
  - 試合詳細 (得点確認): `GET /api/v1.1/game/{gamePk}/feed/live`
- 認証: 不要 (パブリック API)
- レート制限: 非公開 → ポーリング間隔は 30〜60 秒を推奨
- エラー対策: HTTP ステータス別ハンドリング、指数バックオフ、ネットワーク例外処理

## 5. 機能要件

### 5.1 ユースケース

- UC-01: ユーザーは MLB チーム一覧からお気に入りチームを検索・選択できる
- UC-02: 当日の対象チームの試合を自動的に監視対象としてセットできる
- UC-03: 監視中チームが得点した際、即座にデスクトップ通知を受け取れる
- UC-04: 過去の通知履歴 (得点時刻、イニング、スコア) を確認できる
- UC-05: ポーリング間隔、通知サウンドなどの設定を変更できる
- UC-06: API 障害やネットワーク断が発生した際に UI で状況を確認できる

### 5.2 詳細仕様

- チーム登録: 複数チーム (初期上限 3) を監視対象に設定可能
- 試合検出: 当日スケジュールから `gamePk` を特定し `status.abstractGameState === "Live"` の試合を監視
- 得点検出: `feed/live` の `scoringPlays` / `plays.currentPlay` から得点イベントを抽出
- 通知内容: タイトル `{Team Name} scored!`、本文にイニング・プレイヤー・最新スコアを表示
- 通知重複防止: `scoringPlayId` をキャッシュし、同一イベントの再通知を防止
- 試合終了検知: `status.detailedState === "Final"` を検知し監視停止+終了通知
- UI 概要
  - チーム選択ビュー: 検索、登録状況表示
  - ダッシュボード: 監視中試合のスコア、イニング、ステータス
  - 通知履歴: 直近 10 件を表示 (永続保存は任意)
  - 設定画面: ポーリング間隔 (15/30/60 秒・カスタム)、通知サウンド、起動時自動監視、ログレベル
- 国際化対応: 初期は英語 UI、将来的な日本語化を想定した文言管理方式を設計

## 6. 非機能要件

- パフォーマンス: 通知遅延はポーリング間隔 + 2 秒以内、CPU 使用率 5% 未満、メモリ 200MB 以内
- 信頼性: API エラー時は指数バックオフ (最大 5 回) とステータス表示、オフライン時は再試行
- 可観測性: main プロセスでのログ出力 (ファイルローテーション)、重要イベントのログ化
- セキュリティ: すべて HTTPS 利用、実行ファイル署名は将来検討

## 7. アーキテクチャ設計

### 7.1 モジュール構成 (例)

- `main.js`: アプリ起動、メインウィンドウ生成、監視サービス初期化
- `main/services/gameWatcher.ts`: 試合スケジュール取得、得点差分検知ロジック
- `main/services/notifier.ts`: OS 通知ラッパー
- `main/store/settingsStore.ts`: 設定の永続化 (`electron-store`)
- `renderer/App.tsx`: 画面遷移、状態管理
- `renderer/components/TeamSelector.tsx`: チーム検索・登録 UI
- `renderer/components/GameStatusCard.tsx`: 試合状況表示
- `renderer/components/NotificationLog.tsx`: 通知履歴一覧
- `renderer/components/SettingsPanel.tsx`: 設定 UI
- `renderer/store/teamsSlice.ts`, `renderer/store/settingsSlice.ts`: 状態管理 (Redux/Zustand 等)

### 7.2 IPC チャネル (想定)

- `settings:get` / `settings:set`
- `teams:get` / `teams:add` / `teams:remove`
- `watcher:start` / `watcher:stop` / `watcher:status`
- `notifications:history`

### 7.3 データフロー

1. Renderer からチーム設定変更 → IPC で main に送信 → 設定保存 → 監視再起動
2. main がポーリングで得点イベント検出 → 通知 → 通知ログ更新 → Renderer へ送信
3. アプリ起動時に Renderer が設定・監視状況を取得し初期表示

## 8. ポーリング & 通知アルゴリズム

1. 現在日付で `schedule` API を呼び出し対象試合の `gamePk` を取得
2. 試合が `Live` 状態であれば `feed/live` を取得
3. `scoringPlays` から最新イベント ID を取得しキャッシュと比較
4. 未通知イベントがあれば通知を生成 (タイトル・本文組み立て)
5. 試合が `Final` になった場合は終了通知を送付し監視ループを停止
6. API 失敗時は指数バックオフ、最大 5 分待機

## 9. UI/UX 仕様

- 画面一覧
  - ダッシュボード: 監視中試合一覧、スコア、ステータス
  - チーム追加モーダル: 検索、選択、登録
  - 通知履歴パネル: 得点イベントの履歴表示
  - 設定画面: ポーリング、通知、ログに関する設定
- アクセシビリティ: フォーカスインジケータ、十分なコントラスト、スクリーンリーダー向けラベル
- 通知 UX: アプリロゴアイコン、クリックでアプリをフォアグラウンド表示、連続得点時は 5 秒以内の通知をまとめる (将来検討)

## 10. テスト計画

- 単体テスト: API レスポンスパーサー、差分検知ロジック、通知生成関数 (Jest)
- 統合テスト: モック API でのポーリング〜通知 E2E、IPC 通信テスト
- 手動テスト: 実際の試合期間での動作確認、マルチプラットフォーム検証
- CI/CD: GitHub Actions で lint / test、自動ビルド検証

## 11. ログ & 監視

- ローカルログ: `main/logs/app.log` (ローテーション)、重要イベントのレベル分け
- トラブルシューティング: UI からログファイルを開くリンク、エラー時の再試行ボタン

## 12. 保守・拡張性

- 将来拡張: WebSocket / Push 対応、他リーグ対応、詳細スタッツ表示、クラウド同期
- バージョン戦略: セマンティックバージョニング、将来的に自動アップデート (electron-updater) 導入検討
- ドキュメント: API 利用手順、設定ファイル構造、開発手順 (README 整備)

## 13. スケジュール (目安)

| フェーズ | 期間 | 内容 |
| --- | --- | --- |
| 仕様確定 | 1 週間 | 本仕様書レビュー・確定 |
| プロトタイプ | 2 週間 | API 連携、通知実装 |
| UI 実装 | 2 週間 | チーム選択、設定、表示画面 |
| テスト & チューニング | 1-2 週間 | 自動テスト、実機検証 |
| リリース準備 | 1 週間 | ビルド、ドキュメント整備 |

## 14. リスクと対策

- API エンドポイント変更: 抽象化した API クライアントを実装し変更に追随
- ダブルヘッダーなど複数試合: `gamePk` ごとに独立した監視タスクを確保
- 時差対応: 内部的には UTC で統一し UI でローカルタイム表示
- 通知スパム: イニング単位で通知をグルーピング、ユーザーによる通知頻度設定を検討
- シーズンオフ: 過去試合モードまたはメッセージ表示でユーザー体験を維持

## 15. 開発チェックリスト

### 15.1 仕様・要件

- [ ] **仕様書レビュー完了**: 関係者による `spec.md` のレビューと承認を得た
- [ ] **スコープ整理**: スコープ内/外の機能が全員で共有されている
- [ ] **品質基準確認**: 通知遅延、CPU/メモリ制約などの非機能要件を理解した

### 15.2 MLB Stats API 連携

- [ ] **API エンドポイント検証**: `teams`, `schedule`, `feed/live` をサンプルリクエストで確認した
- [ ] **レート制限対策**: ポーリング間隔と指数バックオフの実装方針を確定した
- [ ] **レスポンス型定義**: TypeScript 型を用意し、非互換変更に備えた

### 15.3 アプリケーション構成

- [ ] **main プロセス設計**: 監視サービス、通知、設定保存の責務を設計した
- [ ] **renderer 設計**: 画面構成と状態管理 (Redux/Zustand 等) を決定した
- [ ] **IPC 設計**: `settings`, `teams`, `watcher`, `notifications` のチャネルを定義した

### 15.4 UI/UX

- [ ] **チーム選択 UI**: 検索・登録フローのワイヤーフレーム/モックを作成した
- [ ] **ダッシュボード UI**: 試合ステータス表示の情報設計を完了した
- [ ] **アクセシビリティ**: フォーカス、コントラスト、スクリーンリーダー対応を計画した

### 15.5 通知・監視ロジック

- [ ] **得点判定ロジック**: `scoringPlays` の差分比較アルゴリズムを設計した
- [ ] **重複防止策**: `scoringPlayId` キャッシュの仕様を決定した
- [ ] **終了処理**: 試合終了検知と終了通知の挙動をまとめた

### 15.6 テスト & オブザーバビリティ

- [ ] **テスト計画策定**: 単体/統合/手動テストのケースを洗い出した
- [ ] **ログ方針**: `main/logs/app.log` などの出力仕様を固めた
- [ ] **エラー UI**: API 障害時のユーザー通知方法を設計した

### 15.7 リリース準備

- [ ] **ビルドプロセス**: マルチプラットフォームビルド手順を確立した
- [ ] **ドキュメント整備**: README、セットアップ手順、開発ガイドを更新した
- [ ] **将来拡張計画**: WebSocket 対応などのロードマップを整理した
